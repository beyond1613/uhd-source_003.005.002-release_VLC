<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>UHD: uhd::usrp::multi_usrp Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">UHD
   &#160;<span id="projectnumber">003.005.002-0-unknown</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceuhd.html">uhd</a>      </li>
      <li class="navelem"><a class="el" href="namespaceuhd_1_1usrp.html">usrp</a>      </li>
      <li class="navelem"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html">multi_usrp</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">uhd::usrp::multi_usrp Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="uhd::usrp::multi_usrp" -->
<p><code>#include &lt;<a class="el" href="multi__usrp_8hpp_source.html">multi_usrp.hpp</a>&gt;</code></p>

<p><a href="classuhd_1_1usrp_1_1multi__usrp-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html">multi_usrp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9d9112f5eac0b53a721f2a6c97021fc1">sptr</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1device.html#a439ff67bbcbe999d871a179467355ed0">device::sptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ac425be38f8e2a3463de440e1f2ae1b6d">get_device</a> (void)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuhd_1_1rx__streamer.html#a7e7fc83d61d3bb68efe296ebc0df9c6d">rx_streamer::sptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ab52b893fff58858284c22e0249da4f2b">get_rx_stream</a> (const <a class="el" href="structuhd_1_1stream__args__t.html">stream_args_t</a> &amp;args)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method to get a RX streamer.  <a href="#ab52b893fff58858284c22e0249da4f2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuhd_1_1tx__streamer.html#a137bfe67e240e3d73ef7708155fb9827">tx_streamer::sptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a12ff68a57734461e90f90f4c1cd485ff">get_tx_stream</a> (const <a class="el" href="structuhd_1_1stream__args__t.html">stream_args_t</a> &amp;args)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method to get a TX streamer.  <a href="#a12ff68a57734461e90f90f4c1cd485ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1dict.html">dict</a>&lt; std::string, <br class="typebreak"/>
std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1dadf323c5f00ac4f93b231adc13e34c">get_usrp_rx_info</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1dict.html">dict</a>&lt; std::string, <br class="typebreak"/>
std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#af1b87120ea1f5d9e9d894843a9416578">get_usrp_tx_info</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a99254abfa5259b70a020e667eee619b9">set_master_clock_rate</a> (double rate, size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#aeefd7580630b2baa4e4c90df3a36d9f0">get_master_clock_rate</a> (size_t mboard=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#aa22581d58fdf451c3b118add31a6822c">get_pp_string</a> (void)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#abf885b8812408f9ebd471f2902d1cb70">get_mboard_name</a> (size_t mboard=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afb4bffe3f969c11ee7c0a2cba5178780">get_time_now</a> (size_t mboard=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a55ce95415df2de14a048fca5a04ada03">get_time_last_pps</a> (size_t mboard=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a351a2c3081944a0d2caab95e2a2f0926">set_time_now</a> (const <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> &amp;time_spec, size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a75b1c5375549e6a446d686ee7d9b4e14">set_time_next_pps</a> (const <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> &amp;time_spec, size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a413014bf3aea4a8ea2d268b4a3b390e9">set_time_unknown_pps</a> (const <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> &amp;time_spec)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#acf70237b38918a4b93c37280f6c648b1">get_time_synchronized</a> (void)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a191b78b00d051d3d51c2f719361c1fb5">set_command_time</a> (const <a class="el" href="classuhd_1_1time__spec__t.html">uhd::time_spec_t</a> &amp;time_spec, size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a607aee766d21228a7aaabde2771eb46f">clear_command_time</a> (size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afe50c2b24273d1b3b2a343b73609b310">issue_stream_cmd</a> (const <a class="el" href="structuhd_1_1stream__cmd__t.html">stream_cmd_t</a> &amp;stream_cmd, size_t chan=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a>)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#aceddf575752fda1a8cc75513a1178fd9">set_clock_config</a> (const <a class="el" href="structuhd_1_1clock__config__t.html">clock_config_t</a> &amp;clock_config, size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a57a5580ba06d7d6a037c9ef64f1ea361">set_time_source</a> (const std::string &amp;source, const size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a181262333352a82888af00933d07c3cf">get_time_source</a> (const size_t mboard)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#aee040da1b7ae375e0c08bb0b080d7ccc">get_time_sources</a> (const size_t mboard)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a73ed40009d0d3787c183d42423d25026">set_clock_source</a> (const std::string &amp;source, const size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1e7f679b2f273f7d38eeb1d92e801796">get_clock_source</a> (const size_t mboard)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3e1022d151717e49ce69c987bd07b243">get_clock_sources</a> (const size_t mboard)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ae4efbbc6480fba44939b34c78d44d7e9">get_num_mboards</a> (void)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1sensor__value__t.html">sensor_value_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a2d3c327bcb83fd274e05e3ca95d1ac95">get_mboard_sensor</a> (const std::string &amp;name, size_t mboard=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3a72259c19b80512dba02e40ed5cf028">get_mboard_sensor_names</a> (size_t mboard=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7c74905c18e464b8b3f59fb2dd70dbf3">set_user_register</a> (const boost::uint8_t addr, const boost::uint32_t data, size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7f94ed00059cc7dd30567d031b3f9679">set_rx_subdev_spec</a> (const <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a> &amp;spec, size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a8bacd1b1109656d21da6d5e5f8d417c9">get_rx_subdev_spec</a> (size_t mboard=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afac94be28eadeccb9c230ce839e072e3">get_rx_num_channels</a> (void)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a35004bc7e6d418c2c46b2ca0f34db2e6">get_rx_subdev_name</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a587cfb5be38a16fec532793b34fbf947">set_rx_rate</a> (double rate, size_t chan=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a>)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9bf580742d260257bd7e280666423dc9">get_rx_rate</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1meta__range__t.html">meta_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a6c4200ca796a8c70737b180087f8f93c">get_rx_rates</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1tune__result__t.html">tune_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9b61448f392466e20572fdcb042e8ec6">set_rx_freq</a> (const <a class="el" href="structuhd_1_1tune__request__t.html">tune_request_t</a> &amp;tune_request, size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#adb1c803658f18006efc1dcd67de6d493">get_rx_freq</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceuhd.html#a948ed1f408f7737060d0b6a5d75a135d">freq_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9a5ed2146ac31e641839d00a53df784d">get_rx_freq_range</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceuhd.html#a948ed1f408f7737060d0b6a5d75a135d">freq_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ac63a5b45ca3cc3d74db51a384bba8c2e">get_fe_rx_freq_range</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ad602e7681b796deddd9231f022ffef11">set_rx_gain</a> (double gain, const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a8234968ad1fefef299ef9541cc193915">set_rx_gain</a> (double gain, size_t chan=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience wrapper for setting overall RX gain.  <a href="#a8234968ad1fefef299ef9541cc193915"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a4c406b7964f4cc18dc5b57cafcb345c1">get_rx_gain</a> (const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a6483b85f90a3f46d8181a9b57be1db46">get_rx_gain</a> (size_t chan=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience wrapper for getting overall RX gain.  <a href="#a6483b85f90a3f46d8181a9b57be1db46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceuhd.html#ac9b64ecbaa15596e07f58122c82482e3">gain_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7e077fc7331f7675aa796e030bd8a03e">get_rx_gain_range</a> (const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceuhd.html#ac9b64ecbaa15596e07f58122c82482e3">gain_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7eb3245ee320e9889a477ba753fd8b8c">get_rx_gain_range</a> (size_t chan=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience wrapper for getting overall RX gain range.  <a href="#a7eb3245ee320e9889a477ba753fd8b8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a496745114d83049ed3d0f5fc96e87b2a">get_rx_gain_names</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a72b7947cb0c434b98e9915f91b8f8fe0">set_rx_antenna</a> (const std::string &amp;ant, size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ad2d35d85aebebfdd2d14cee2850243af">get_rx_antenna</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7c1202c5cc978663182adec8c07d8521">get_rx_antennas</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#a009518b78c453470e2856bebf2746f37">UHD_DEPRECATED</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a54dc279c0f3a034ea1a5d80ebd8c4b35">get_rx_lo_locked</a> (size_t chan=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a4e026819f286e69c48c2e1956d95c6fb">set_rx_bandwidth</a> (double bandwidth, size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a90d7826c7b96aed88c74ffc035b7f0dd">get_rx_bandwidth</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1meta__range__t.html">meta_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#af71672f89943c87a87f03821e5c185c5">get_rx_bandwidth_range</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#a009518b78c453470e2856bebf2746f37">UHD_DEPRECATED</a> double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1337a38862d6eb27db0aabe30977d8d1">read_rssi</a> (size_t chan=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1usrp_1_1dboard__iface.html#a59c880b1ce74b17f9aec67426d37a4c8">dboard_iface::sptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3299d8f77f1d823c762e36438bac509e">get_rx_dboard_iface</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1sensor__value__t.html">sensor_value_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#acd37d327931cec64e3701eb2a5aa7bfb">get_rx_sensor</a> (const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a87d3d097b6cb1cfa940896e71e5f44ad">get_rx_sensor_names</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7beb49c1a04a81b3e7569db482453746">set_rx_dc_offset</a> (const bool enb, size_t chan=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a>)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a8b8212c1131a34823430c9bdec9c183f">set_rx_dc_offset</a> (const std::complex&lt; double &gt; &amp;offset, size_t chan=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a>)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7ccd212322a5da010ba79f9f18561156">set_rx_iq_balance</a> (const std::complex&lt; double &gt; &amp;correction, size_t chan=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a>)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3b8d9d9fb9a1ec51e81a207cd299e517">set_tx_subdev_spec</a> (const <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a> &amp;spec, size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a070b4bb3cf27436fb9104a414bc9f3f7">get_tx_subdev_spec</a> (size_t mboard=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3be03eb72575c9d5526c93dd133e96d3">get_tx_num_channels</a> (void)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a4b0632b6ddff26e9d0bd22990274f99d">get_tx_subdev_name</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ab8bc17744d3ee94b7c5cdcb75457bd6b">set_tx_rate</a> (double rate, size_t chan=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a>)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a2b75c9dd5ad3c9378f079f4950b043dd">get_tx_rate</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1meta__range__t.html">meta_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a36270e66858e63bd8c887fc127782fb5">get_tx_rates</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1tune__result__t.html">tune_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ae7a674a9d012a78dd4f2ded478839124">set_tx_freq</a> (const <a class="el" href="structuhd_1_1tune__request__t.html">tune_request_t</a> &amp;tune_request, size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9ac9b0e10e67d967c06e8dd6511b5919">get_tx_freq</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceuhd.html#a948ed1f408f7737060d0b6a5d75a135d">freq_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a898502a489319cd64230bb0e50d9ab0a">get_tx_freq_range</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceuhd.html#a948ed1f408f7737060d0b6a5d75a135d">freq_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ad5418609a1d90f8deb21419bf78fec0f">get_fe_tx_freq_range</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a41cc3c774451d0a2c5f69cd8df0f9f06">set_tx_gain</a> (double gain, const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1101dc00b016fe91a299cbcae8b12053">set_tx_gain</a> (double gain, size_t chan=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience wrapper for setting overall TX gain.  <a href="#a1101dc00b016fe91a299cbcae8b12053"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ae88320fb12dd6ebfc4b9f6bc4074f11b">get_tx_gain</a> (const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a612c00086f9968380bcf51f877b544b7">get_tx_gain</a> (size_t chan=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience wrapper for getting overall TX gain.  <a href="#a612c00086f9968380bcf51f877b544b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceuhd.html#ac9b64ecbaa15596e07f58122c82482e3">gain_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ab99753a578657046f7a0ce72f666abdc">get_tx_gain_range</a> (const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceuhd.html#ac9b64ecbaa15596e07f58122c82482e3">gain_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a6ec9889b9b64d1d8e2a308c0b0c328ec">get_tx_gain_range</a> (size_t chan=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience wrapper for getting overall TX gain range.  <a href="#a6ec9889b9b64d1d8e2a308c0b0c328ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9f5589722a2a1491fc393a6b98f094b0">get_tx_gain_names</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a4e8cd16aa93bf3375cdcd3daca3b6b24">set_tx_antenna</a> (const std::string &amp;ant, size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7f3e6094ff76cc3d0630e46cb291bcfd">get_tx_antenna</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a38b10a6bd2128b3810da229c60b31aa1">get_tx_antennas</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#a009518b78c453470e2856bebf2746f37">UHD_DEPRECATED</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#af8a7f16e35466a50e7a8a4e71b3598fb">get_tx_lo_locked</a> (size_t chan=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ad04bfc300735435a7937d4eb37e5523d">set_tx_bandwidth</a> (double bandwidth, size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a227fd46437f562b8f8f6d4a98cd1c5dc">get_tx_bandwidth</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1meta__range__t.html">meta_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#abebc07fa60f37453a8ac3d6ff2fc7aec">get_tx_bandwidth_range</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1usrp_1_1dboard__iface.html#a59c880b1ce74b17f9aec67426d37a4c8">dboard_iface::sptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#abe3261f1f763a026707dea80ac466d1c">get_tx_dboard_iface</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1sensor__value__t.html">sensor_value_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a482d52c0983c6db913209e57f9b79c3a">get_tx_sensor</a> (const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a33a556057ceabc00ab2af61525f206fd">get_tx_sensor_names</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a263ab7f0364c03e8a6e330c546769e4f">set_tx_dc_offset</a> (const std::complex&lt; double &gt; &amp;offset, size_t chan=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a>)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ad938e609a11773e21611ee86a0e1b1c5">set_tx_iq_balance</a> (const std::complex&lt; double &gt; &amp;correction, size_t chan=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a>)=0</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9d9112f5eac0b53a721f2a6c97021fc1">sptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#af0d3809a8f8dcd3c962ad5b9a0a6456c">make</a> (const <a class="el" href="classuhd_1_1device__addr__t.html">device_addr_t</a> &amp;dev_addr)</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a> = size_t(~0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A wildcard motherboard index.  <a href="#a21f2ba01462e1f211a8823fda24a82d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a> = size_t(~0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A wildcard channel index.  <a href="#afeaca319029cb49f7041461345ab641c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a524b7e2177492e59382f1124ee32c12b">ALL_GAINS</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A wildcard gain element name.  <a href="#a524b7e2177492e59382f1124ee32c12b"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The Multi-USRP device class:</p>
<p>This class facilitates ease-of-use for most use-case scenarios. The wrapper provides convenience functions to tune the devices, set the dboard gains, antennas, filters, and other properties. This class can be used to interface with a single USRP with one or more channels, or multiple USRPs in a homogeneous setup. All members take an optional parameter for board number or channel number. In the single device, single channel case, these parameters can be unspecified.</p>
<p>When using a single device with multiple channels:</p>
<ul>
<li>Channel mapping is determined by the frontend specifications</li>
<li>All channels share a common RX sample rate</li>
<li>All channels share a common TX sample rate</li>
</ul>
<p>When using multiple devices in a configuration:</p>
<ul>
<li>Channel mapping is determined by the device address arguments</li>
<li>All boards share a common RX sample rate</li>
<li>All boards share a common TX sample rate</li>
<li>All boards share a common RX frontend specification size</li>
<li>All boards share a common TX frontend specification size</li>
<li>All boards must have synchronized times (see the set_time_*() calls)</li>
</ul>
<p>Example to setup channel mapping for multiple devices: </p>
<pre></pre><pre> //create a <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html">multi_usrp</a> with two boards in the configuration
 <a class="el" href="classuhd_1_1device__addr__t.html">device_addr_t</a> dev_addr;
 dev_addr["addr0"] = "192.168.10.2"
 dev_addr["addr1"] = "192.168.10.3";
 <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9d9112f5eac0b53a721f2a6c97021fc1">multi_usrp::sptr</a> dev = multi_usrp::make(dev_addr);</pre><pre> //set the board on 10.2 to use the A RX frontend (RX channel 0)
 dev-&gt;set_rx_subdev_spec("A:A", 0);</pre><pre> //set the board on 10.3 to use the B RX frontend (RX channel 1)
 dev-&gt;set_rx_subdev_spec("A:B", 1);</pre><pre> //set both boards to use the AB TX frontend (TX channels 0 and 1)
 dev-&gt;set_tx_subdev_spec("A:AB", <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5" title="A wildcard motherboard index.">multi_usrp::ALL_MBOARDS</a>);</pre><pre> //now that all the channels are mapped, continue with configuration...</pre><pre> </pre> </div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a9d9112f5eac0b53a721f2a6c97021fc1"></a><!-- doxytag: member="uhd::usrp::multi_usrp::sptr" ref="a9d9112f5eac0b53a721f2a6c97021fc1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html">multi_usrp</a>&gt; <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9d9112f5eac0b53a721f2a6c97021fc1">uhd::usrp::multi_usrp::sptr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a607aee766d21228a7aaabde2771eb46f"></a><!-- doxytag: member="uhd::usrp::multi_usrp::clear_command_time" ref="a607aee766d21228a7aaabde2771eb46f" args="(size_t mboard=ALL_MBOARDS)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a607aee766d21228a7aaabde2771eb46f">uhd::usrp::multi_usrp::clear_command_time</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clear the command time so future commands are sent ASAP.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>which motherboard to set the config </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1e7f679b2f273f7d38eeb1d92e801796"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_clock_source" ref="a1e7f679b2f273f7d38eeb1d92e801796" args="(const size_t mboard)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1e7f679b2f273f7d38eeb1d92e801796">uhd::usrp::multi_usrp::get_clock_source</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the currently set clock source. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>which motherboard to get the config </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the string representing the clock source </dd></dl>

</div>
</div>
<a class="anchor" id="a3e1022d151717e49ce69c987bd07b243"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_clock_sources" ref="a3e1022d151717e49ce69c987bd07b243" args="(const size_t mboard)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3e1022d151717e49ce69c987bd07b243">uhd::usrp::multi_usrp::get_clock_sources</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a list of possible clock sources. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>which motherboard to get the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector of strings for possible settings </dd></dl>

</div>
</div>
<a class="anchor" id="ac425be38f8e2a3463de440e1f2ae1b6d"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_device" ref="ac425be38f8e2a3463de440e1f2ae1b6d" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1device.html#a439ff67bbcbe999d871a179467355ed0">device::sptr</a> <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ac425be38f8e2a3463de440e1f2ae1b6d">uhd::usrp::multi_usrp::get_device</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the underlying device object. This is needed to get access to the streaming API and properties. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the device object within this single usrp </dd></dl>

</div>
</div>
<a class="anchor" id="ac63a5b45ca3cc3d74db51a384bba8c2e"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_fe_rx_freq_range" ref="ac63a5b45ca3cc3d74db51a384bba8c2e" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceuhd.html#a948ed1f408f7737060d0b6a5d75a135d">freq_range_t</a> <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ac63a5b45ca3cc3d74db51a384bba8c2e">uhd::usrp::multi_usrp::get_fe_rx_freq_range</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the center frequency range of the RF frontend. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a frequency range object </dd></dl>

</div>
</div>
<a class="anchor" id="ad5418609a1d90f8deb21419bf78fec0f"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_fe_tx_freq_range" ref="ad5418609a1d90f8deb21419bf78fec0f" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceuhd.html#a948ed1f408f7737060d0b6a5d75a135d">freq_range_t</a> <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ad5418609a1d90f8deb21419bf78fec0f">uhd::usrp::multi_usrp::get_fe_tx_freq_range</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the center frequency range of the TX frontend. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a frequency range object </dd></dl>

</div>
</div>
<a class="anchor" id="aeefd7580630b2baa4e4c90df3a36d9f0"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_master_clock_rate" ref="aeefd7580630b2baa4e4c90df3a36d9f0" args="(size_t mboard=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#aeefd7580630b2baa4e4c90df3a36d9f0">uhd::usrp::multi_usrp::get_master_clock_rate</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the master clock rate. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the master clock rate in Hz. </dd></dl>

</div>
</div>
<a class="anchor" id="abf885b8812408f9ebd471f2902d1cb70"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_mboard_name" ref="abf885b8812408f9ebd471f2902d1cb70" args="(size_t mboard=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#abf885b8812408f9ebd471f2902d1cb70">uhd::usrp::multi_usrp::get_mboard_name</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get canonical name for this USRP motherboard. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>which motherboard to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a string representing the name </dd></dl>

</div>
</div>
<a class="anchor" id="a2d3c327bcb83fd274e05e3ca95d1ac95"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_mboard_sensor" ref="a2d3c327bcb83fd274e05e3ca95d1ac95" args="(const std::string &amp;name, size_t mboard=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1sensor__value__t.html">sensor_value_t</a> <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a2d3c327bcb83fd274e05e3ca95d1ac95">uhd::usrp::multi_usrp::get_mboard_sensor</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a motherboard sensor value. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the sensor </td></tr>
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a sensor value object </dd></dl>

</div>
</div>
<a class="anchor" id="a3a72259c19b80512dba02e40ed5cf028"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_mboard_sensor_names" ref="a3a72259c19b80512dba02e40ed5cf028" args="(size_t mboard=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3a72259c19b80512dba02e40ed5cf028">uhd::usrp::multi_usrp::get_mboard_sensor_names</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a list of possible motherboard sensor names. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector of sensor names </dd></dl>

</div>
</div>
<a class="anchor" id="ae4efbbc6480fba44939b34c78d44d7e9"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_num_mboards" ref="ae4efbbc6480fba44939b34c78d44d7e9" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ae4efbbc6480fba44939b34c78d44d7e9">uhd::usrp::multi_usrp::get_num_mboards</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the number of USRP motherboards in this configuration. </p>

</div>
</div>
<a class="anchor" id="aa22581d58fdf451c3b118add31a6822c"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_pp_string" ref="aa22581d58fdf451c3b118add31a6822c" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#aa22581d58fdf451c3b118add31a6822c">uhd::usrp::multi_usrp::get_pp_string</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a printable summary for this USRP configuration. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a printable string </dd></dl>

</div>
</div>
<a class="anchor" id="ad2d35d85aebebfdd2d14cee2850243af"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_antenna" ref="ad2d35d85aebebfdd2d14cee2850243af" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ad2d35d85aebebfdd2d14cee2850243af">uhd::usrp::multi_usrp::get_rx_antenna</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the selected RX antenna on the frontend. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the antenna name </dd></dl>

</div>
</div>
<a class="anchor" id="a7c1202c5cc978663182adec8c07d8521"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_antennas" ref="a7c1202c5cc978663182adec8c07d8521" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7c1202c5cc978663182adec8c07d8521">uhd::usrp::multi_usrp::get_rx_antennas</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a list of possible RX antennas on the frontend. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector of antenna names </dd></dl>

</div>
</div>
<a class="anchor" id="a90d7826c7b96aed88c74ffc035b7f0dd"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_bandwidth" ref="a90d7826c7b96aed88c74ffc035b7f0dd" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a90d7826c7b96aed88c74ffc035b7f0dd">uhd::usrp::multi_usrp::get_rx_bandwidth</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the RX bandwidth on the frontend. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the bandwidth in Hz </dd></dl>

</div>
</div>
<a class="anchor" id="af71672f89943c87a87f03821e5c185c5"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_bandwidth_range" ref="af71672f89943c87a87f03821e5c185c5" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1meta__range__t.html">meta_range_t</a> <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#af71672f89943c87a87f03821e5c185c5">uhd::usrp::multi_usrp::get_rx_bandwidth_range</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the range of the possible RX bandwidth settings. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a range of bandwidths in Hz </dd></dl>

</div>
</div>
<a class="anchor" id="a3299d8f77f1d823c762e36438bac509e"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_dboard_iface" ref="a3299d8f77f1d823c762e36438bac509e" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1usrp_1_1dboard__iface.html#a59c880b1ce74b17f9aec67426d37a4c8">dboard_iface::sptr</a> <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3299d8f77f1d823c762e36438bac509e">uhd::usrp::multi_usrp::get_rx_dboard_iface</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the dboard interface object for the RX frontend. The dboard interface gives access to GPIOs, SPI, I2C, low-speed ADC and DAC. Use at your own risk! </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the dboard interface sptr </dd></dl>

</div>
</div>
<a class="anchor" id="adb1c803658f18006efc1dcd67de6d493"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_freq" ref="adb1c803658f18006efc1dcd67de6d493" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#adb1c803658f18006efc1dcd67de6d493">uhd::usrp::multi_usrp::get_rx_freq</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the RX center frequency. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the frequency in Hz </dd></dl>

</div>
</div>
<a class="anchor" id="a9a5ed2146ac31e641839d00a53df784d"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_freq_range" ref="a9a5ed2146ac31e641839d00a53df784d" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceuhd.html#a948ed1f408f7737060d0b6a5d75a135d">freq_range_t</a> <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9a5ed2146ac31e641839d00a53df784d">uhd::usrp::multi_usrp::get_rx_freq_range</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the RX center frequency range. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a frequency range object </dd></dl>

</div>
</div>
<a class="anchor" id="a4c406b7964f4cc18dc5b57cafcb345c1"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_gain" ref="a4c406b7964f4cc18dc5b57cafcb345c1" args="(const std::string &amp;name, size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a4c406b7964f4cc18dc5b57cafcb345c1">uhd::usrp::multi_usrp::get_rx_gain</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the RX gain value for the specified gain element. For an empty name, sum across all gain elements. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the gain element </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the gain in dB </dd></dl>

</div>
</div>
<a class="anchor" id="a6483b85f90a3f46d8181a9b57be1db46"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_gain" ref="a6483b85f90a3f46d8181a9b57be1db46" args="(size_t chan=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a4c406b7964f4cc18dc5b57cafcb345c1">uhd::usrp::multi_usrp::get_rx_gain</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A convenience wrapper for getting overall RX gain. </p>

</div>
</div>
<a class="anchor" id="a496745114d83049ed3d0f5fc96e87b2a"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_gain_names" ref="a496745114d83049ed3d0f5fc96e87b2a" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a496745114d83049ed3d0f5fc96e87b2a">uhd::usrp::multi_usrp::get_rx_gain_names</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the names of the gain elements in the RX chain. Gain elements are ordered from antenna to FPGA. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector of gain element names </dd></dl>

</div>
</div>
<a class="anchor" id="a7e077fc7331f7675aa796e030bd8a03e"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_gain_range" ref="a7e077fc7331f7675aa796e030bd8a03e" args="(const std::string &amp;name, size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceuhd.html#ac9b64ecbaa15596e07f58122c82482e3">gain_range_t</a> <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7e077fc7331f7675aa796e030bd8a03e">uhd::usrp::multi_usrp::get_rx_gain_range</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the RX gain range for the specified gain element. For an empty name, calculate the overall gain range. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the gain element </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a gain range object </dd></dl>

</div>
</div>
<a class="anchor" id="a7eb3245ee320e9889a477ba753fd8b8c"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_gain_range" ref="a7eb3245ee320e9889a477ba753fd8b8c" args="(size_t chan=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceuhd.html#ac9b64ecbaa15596e07f58122c82482e3">gain_range_t</a> <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7e077fc7331f7675aa796e030bd8a03e">uhd::usrp::multi_usrp::get_rx_gain_range</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A convenience wrapper for getting overall RX gain range. </p>

</div>
</div>
<a class="anchor" id="a54dc279c0f3a034ea1a5d80ebd8c4b35"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_lo_locked" ref="a54dc279c0f3a034ea1a5d80ebd8c4b35" args="(size_t chan=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#a009518b78c453470e2856bebf2746f37">UHD_DEPRECATED</a> bool <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a54dc279c0f3a034ea1a5d80ebd8c4b35">uhd::usrp::multi_usrp::get_rx_lo_locked</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the locked status of the LO on the frontend. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true for locked </dd></dl>

</div>
</div>
<a class="anchor" id="afac94be28eadeccb9c230ce839e072e3"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_num_channels" ref="afac94be28eadeccb9c230ce839e072e3" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afac94be28eadeccb9c230ce839e072e3">uhd::usrp::multi_usrp::get_rx_num_channels</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the number of RX channels in this configuration. This is the number of USRPs times the number of RX channels per board, where the number of RX channels per board is homogeneous among all USRPs. </p>

</div>
</div>
<a class="anchor" id="a9bf580742d260257bd7e280666423dc9"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_rate" ref="a9bf580742d260257bd7e280666423dc9" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9bf580742d260257bd7e280666423dc9">uhd::usrp::multi_usrp::get_rx_rate</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the RX sample rate. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the rate in Sps </dd></dl>

</div>
</div>
<a class="anchor" id="a6c4200ca796a8c70737b180087f8f93c"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_rates" ref="a6c4200ca796a8c70737b180087f8f93c" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1meta__range__t.html">meta_range_t</a> <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a6c4200ca796a8c70737b180087f8f93c">uhd::usrp::multi_usrp::get_rx_rates</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a range of possible RX rates. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the meta range of rates </dd></dl>

</div>
</div>
<a class="anchor" id="acd37d327931cec64e3701eb2a5aa7bfb"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_sensor" ref="acd37d327931cec64e3701eb2a5aa7bfb" args="(const std::string &amp;name, size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1sensor__value__t.html">sensor_value_t</a> <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#acd37d327931cec64e3701eb2a5aa7bfb">uhd::usrp::multi_usrp::get_rx_sensor</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get an RX frontend sensor value. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the sensor </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a sensor value object </dd></dl>

</div>
</div>
<a class="anchor" id="a87d3d097b6cb1cfa940896e71e5f44ad"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_sensor_names" ref="a87d3d097b6cb1cfa940896e71e5f44ad" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a87d3d097b6cb1cfa940896e71e5f44ad">uhd::usrp::multi_usrp::get_rx_sensor_names</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a list of possible RX frontend sensor names. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector of sensor names </dd></dl>

</div>
</div>
<a class="anchor" id="ab52b893fff58858284c22e0249da4f2b"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_stream" ref="ab52b893fff58858284c22e0249da4f2b" args="(const stream_args_t &amp;args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuhd_1_1rx__streamer.html#a7e7fc83d61d3bb68efe296ebc0df9c6d">rx_streamer::sptr</a> <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ab52b893fff58858284c22e0249da4f2b">uhd::usrp::multi_usrp::get_rx_stream</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structuhd_1_1stream__args__t.html">stream_args_t</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to get a RX streamer. </p>

</div>
</div>
<a class="anchor" id="a35004bc7e6d418c2c46b2ca0f34db2e6"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_subdev_name" ref="a35004bc7e6d418c2c46b2ca0f34db2e6" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a35004bc7e6d418c2c46b2ca0f34db2e6">uhd::usrp::multi_usrp::get_rx_subdev_name</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the name of the RX frontend. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the frontend name </dd></dl>

</div>
</div>
<a class="anchor" id="a8bacd1b1109656d21da6d5e5f8d417c9"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_subdev_spec" ref="a8bacd1b1109656d21da6d5e5f8d417c9" args="(size_t mboard=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a> <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a8bacd1b1109656d21da6d5e5f8d417c9">uhd::usrp::multi_usrp::get_rx_subdev_spec</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the RX frontend specification. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the frontend specification in use </dd></dl>

</div>
</div>
<a class="anchor" id="a55ce95415df2de14a048fca5a04ada03"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_time_last_pps" ref="a55ce95415df2de14a048fca5a04ada03" args="(size_t mboard=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a55ce95415df2de14a048fca5a04ada03">uhd::usrp::multi_usrp::get_time_last_pps</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the time when the last pps pulse occured. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>which motherboard to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a timespec representing the last pps </dd></dl>

</div>
</div>
<a class="anchor" id="afb4bffe3f969c11ee7c0a2cba5178780"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_time_now" ref="afb4bffe3f969c11ee7c0a2cba5178780" args="(size_t mboard=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afb4bffe3f969c11ee7c0a2cba5178780">uhd::usrp::multi_usrp::get_time_now</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the current time in the usrp time registers. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>which motherboard to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a timespec representing current usrp time </dd></dl>

</div>
</div>
<a class="anchor" id="a181262333352a82888af00933d07c3cf"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_time_source" ref="a181262333352a82888af00933d07c3cf" args="(const size_t mboard)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a181262333352a82888af00933d07c3cf">uhd::usrp::multi_usrp::get_time_source</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the currently set time source. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>which motherboard to get the config </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the string representing the time source </dd></dl>

</div>
</div>
<a class="anchor" id="aee040da1b7ae375e0c08bb0b080d7ccc"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_time_sources" ref="aee040da1b7ae375e0c08bb0b080d7ccc" args="(const size_t mboard)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#aee040da1b7ae375e0c08bb0b080d7ccc">uhd::usrp::multi_usrp::get_time_sources</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a list of possible time sources. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>which motherboard to get the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector of strings for possible settings </dd></dl>

</div>
</div>
<a class="anchor" id="acf70237b38918a4b93c37280f6c648b1"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_time_synchronized" ref="acf70237b38918a4b93c37280f6c648b1" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#acf70237b38918a4b93c37280f6c648b1">uhd::usrp::multi_usrp::get_time_synchronized</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Are the times across all motherboards in this configuration synchronized? Checks that all time registers are approximately close but not exact, given that the RTT may varying for a control packet transaction. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true when all motherboards time registers are in sync </dd></dl>

</div>
</div>
<a class="anchor" id="a7f3e6094ff76cc3d0630e46cb291bcfd"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_antenna" ref="a7f3e6094ff76cc3d0630e46cb291bcfd" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7f3e6094ff76cc3d0630e46cb291bcfd">uhd::usrp::multi_usrp::get_tx_antenna</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the selected TX antenna on the frontend. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the antenna name </dd></dl>

</div>
</div>
<a class="anchor" id="a38b10a6bd2128b3810da229c60b31aa1"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_antennas" ref="a38b10a6bd2128b3810da229c60b31aa1" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a38b10a6bd2128b3810da229c60b31aa1">uhd::usrp::multi_usrp::get_tx_antennas</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a list of possible TX antennas on the frontend. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector of antenna names </dd></dl>

</div>
</div>
<a class="anchor" id="a227fd46437f562b8f8f6d4a98cd1c5dc"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_bandwidth" ref="a227fd46437f562b8f8f6d4a98cd1c5dc" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a227fd46437f562b8f8f6d4a98cd1c5dc">uhd::usrp::multi_usrp::get_tx_bandwidth</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the TX bandwidth on the frontend. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the bandwidth in Hz </dd></dl>

</div>
</div>
<a class="anchor" id="abebc07fa60f37453a8ac3d6ff2fc7aec"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_bandwidth_range" ref="abebc07fa60f37453a8ac3d6ff2fc7aec" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1meta__range__t.html">meta_range_t</a> <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#abebc07fa60f37453a8ac3d6ff2fc7aec">uhd::usrp::multi_usrp::get_tx_bandwidth_range</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the range of the possible TX bandwidth settings. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a range of bandwidths in Hz </dd></dl>

</div>
</div>
<a class="anchor" id="abe3261f1f763a026707dea80ac466d1c"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_dboard_iface" ref="abe3261f1f763a026707dea80ac466d1c" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1usrp_1_1dboard__iface.html#a59c880b1ce74b17f9aec67426d37a4c8">dboard_iface::sptr</a> <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#abe3261f1f763a026707dea80ac466d1c">uhd::usrp::multi_usrp::get_tx_dboard_iface</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the dboard interface object for the TX frontend. The dboard interface gives access to GPIOs, SPI, I2C, low-speed ADC and DAC. Use at your own risk! </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the dboard interface sptr </dd></dl>

</div>
</div>
<a class="anchor" id="a9ac9b0e10e67d967c06e8dd6511b5919"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_freq" ref="a9ac9b0e10e67d967c06e8dd6511b5919" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9ac9b0e10e67d967c06e8dd6511b5919">uhd::usrp::multi_usrp::get_tx_freq</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the TX center frequency. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the frequency in Hz </dd></dl>

</div>
</div>
<a class="anchor" id="a898502a489319cd64230bb0e50d9ab0a"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_freq_range" ref="a898502a489319cd64230bb0e50d9ab0a" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceuhd.html#a948ed1f408f7737060d0b6a5d75a135d">freq_range_t</a> <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a898502a489319cd64230bb0e50d9ab0a">uhd::usrp::multi_usrp::get_tx_freq_range</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the TX center frequency range. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a frequency range object </dd></dl>

</div>
</div>
<a class="anchor" id="ae88320fb12dd6ebfc4b9f6bc4074f11b"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_gain" ref="ae88320fb12dd6ebfc4b9f6bc4074f11b" args="(const std::string &amp;name, size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ae88320fb12dd6ebfc4b9f6bc4074f11b">uhd::usrp::multi_usrp::get_tx_gain</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the TX gain value for the specified gain element. For an empty name, sum across all gain elements. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the gain element </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the gain in dB </dd></dl>

</div>
</div>
<a class="anchor" id="a612c00086f9968380bcf51f877b544b7"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_gain" ref="a612c00086f9968380bcf51f877b544b7" args="(size_t chan=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ae88320fb12dd6ebfc4b9f6bc4074f11b">uhd::usrp::multi_usrp::get_tx_gain</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A convenience wrapper for getting overall TX gain. </p>

</div>
</div>
<a class="anchor" id="a9f5589722a2a1491fc393a6b98f094b0"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_gain_names" ref="a9f5589722a2a1491fc393a6b98f094b0" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9f5589722a2a1491fc393a6b98f094b0">uhd::usrp::multi_usrp::get_tx_gain_names</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the names of the gain elements in the TX chain. Gain elements are ordered from antenna to FPGA. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector of gain element names </dd></dl>

</div>
</div>
<a class="anchor" id="ab99753a578657046f7a0ce72f666abdc"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_gain_range" ref="ab99753a578657046f7a0ce72f666abdc" args="(const std::string &amp;name, size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceuhd.html#ac9b64ecbaa15596e07f58122c82482e3">gain_range_t</a> <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ab99753a578657046f7a0ce72f666abdc">uhd::usrp::multi_usrp::get_tx_gain_range</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the TX gain range for the specified gain element. For an empty name, calculate the overall gain range. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the gain element </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a gain range object </dd></dl>

</div>
</div>
<a class="anchor" id="a6ec9889b9b64d1d8e2a308c0b0c328ec"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_gain_range" ref="a6ec9889b9b64d1d8e2a308c0b0c328ec" args="(size_t chan=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceuhd.html#ac9b64ecbaa15596e07f58122c82482e3">gain_range_t</a> <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ab99753a578657046f7a0ce72f666abdc">uhd::usrp::multi_usrp::get_tx_gain_range</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A convenience wrapper for getting overall TX gain range. </p>

</div>
</div>
<a class="anchor" id="af8a7f16e35466a50e7a8a4e71b3598fb"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_lo_locked" ref="af8a7f16e35466a50e7a8a4e71b3598fb" args="(size_t chan=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#a009518b78c453470e2856bebf2746f37">UHD_DEPRECATED</a> bool <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#af8a7f16e35466a50e7a8a4e71b3598fb">uhd::usrp::multi_usrp::get_tx_lo_locked</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the locked status of the LO on the frontend. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true for locked </dd></dl>

</div>
</div>
<a class="anchor" id="a3be03eb72575c9d5526c93dd133e96d3"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_num_channels" ref="a3be03eb72575c9d5526c93dd133e96d3" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3be03eb72575c9d5526c93dd133e96d3">uhd::usrp::multi_usrp::get_tx_num_channels</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the number of TX channels in this configuration. This is the number of USRPs times the number of TX channels per board, where the number of TX channels per board is homogeneous among all USRPs. </p>

</div>
</div>
<a class="anchor" id="a2b75c9dd5ad3c9378f079f4950b043dd"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_rate" ref="a2b75c9dd5ad3c9378f079f4950b043dd" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a2b75c9dd5ad3c9378f079f4950b043dd">uhd::usrp::multi_usrp::get_tx_rate</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the TX sample rate. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the rate in Sps </dd></dl>

</div>
</div>
<a class="anchor" id="a36270e66858e63bd8c887fc127782fb5"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_rates" ref="a36270e66858e63bd8c887fc127782fb5" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1meta__range__t.html">meta_range_t</a> <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a36270e66858e63bd8c887fc127782fb5">uhd::usrp::multi_usrp::get_tx_rates</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a range of possible TX rates. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the meta range of rates </dd></dl>

</div>
</div>
<a class="anchor" id="a482d52c0983c6db913209e57f9b79c3a"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_sensor" ref="a482d52c0983c6db913209e57f9b79c3a" args="(const std::string &amp;name, size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1sensor__value__t.html">sensor_value_t</a> <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a482d52c0983c6db913209e57f9b79c3a">uhd::usrp::multi_usrp::get_tx_sensor</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get an TX frontend sensor value. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the sensor </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a sensor value object </dd></dl>

</div>
</div>
<a class="anchor" id="a33a556057ceabc00ab2af61525f206fd"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_sensor_names" ref="a33a556057ceabc00ab2af61525f206fd" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a33a556057ceabc00ab2af61525f206fd">uhd::usrp::multi_usrp::get_tx_sensor_names</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a list of possible TX frontend sensor names. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector of sensor names </dd></dl>

</div>
</div>
<a class="anchor" id="a12ff68a57734461e90f90f4c1cd485ff"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_stream" ref="a12ff68a57734461e90f90f4c1cd485ff" args="(const stream_args_t &amp;args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuhd_1_1tx__streamer.html#a137bfe67e240e3d73ef7708155fb9827">tx_streamer::sptr</a> <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a12ff68a57734461e90f90f4c1cd485ff">uhd::usrp::multi_usrp::get_tx_stream</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structuhd_1_1stream__args__t.html">stream_args_t</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to get a TX streamer. </p>

</div>
</div>
<a class="anchor" id="a4b0632b6ddff26e9d0bd22990274f99d"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_subdev_name" ref="a4b0632b6ddff26e9d0bd22990274f99d" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a4b0632b6ddff26e9d0bd22990274f99d">uhd::usrp::multi_usrp::get_tx_subdev_name</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the name of the TX frontend. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the frontend name </dd></dl>

</div>
</div>
<a class="anchor" id="a070b4bb3cf27436fb9104a414bc9f3f7"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_subdev_spec" ref="a070b4bb3cf27436fb9104a414bc9f3f7" args="(size_t mboard=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a> <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a070b4bb3cf27436fb9104a414bc9f3f7">uhd::usrp::multi_usrp::get_tx_subdev_spec</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the TX frontend specification. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the frontend specification in use </dd></dl>

</div>
</div>
<a class="anchor" id="a1dadf323c5f00ac4f93b231adc13e34c"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_usrp_rx_info" ref="a1dadf323c5f00ac4f93b231adc13e34c" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1dict.html">dict</a>&lt;std::string, std::string&gt; <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1dadf323c5f00ac4f93b231adc13e34c">uhd::usrp::multi_usrp::get_usrp_rx_info</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns identifying information about this USRP's configuration. Returns motherboard ID, name, and serial. Returns daughterboard RX ID, subdev name and spec, serial, and antenna. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RX info </dd></dl>

</div>
</div>
<a class="anchor" id="af1b87120ea1f5d9e9d894843a9416578"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_usrp_tx_info" ref="af1b87120ea1f5d9e9d894843a9416578" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1dict.html">dict</a>&lt;std::string, std::string&gt; <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#af1b87120ea1f5d9e9d894843a9416578">uhd::usrp::multi_usrp::get_usrp_tx_info</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns identifying information about this USRP's configuration. Returns motherboard ID, name, and serial. Returns daughterboard TX ID, subdev name and spec, serial, and antenna. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TX info </dd></dl>

</div>
</div>
<a class="anchor" id="afe50c2b24273d1b3b2a343b73609b310"></a><!-- doxytag: member="uhd::usrp::multi_usrp::issue_stream_cmd" ref="afe50c2b24273d1b3b2a343b73609b310" args="(const stream_cmd_t &amp;stream_cmd, size_t chan=ALL_CHANS)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afe50c2b24273d1b3b2a343b73609b310">uhd::usrp::multi_usrp::issue_stream_cmd</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structuhd_1_1stream__cmd__t.html">stream_cmd_t</a> &amp;&#160;</td>
          <td class="paramname"><em>stream_cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Issue a stream command to the usrp device. This tells the usrp to send samples into the host. See the documentation for <a class="el" href="structuhd_1_1stream__cmd__t.html">stream_cmd_t</a> for more info.</p>
<p>With multiple devices, the first stream command in a chain of commands should have a time spec in the near future and stream_now = false; to ensure that the packets can be aligned by their time specs.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">stream_cmd</td><td>the stream command to issue </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0d3809a8f8dcd3c962ad5b9a0a6456c"></a><!-- doxytag: member="uhd::usrp::multi_usrp::make" ref="af0d3809a8f8dcd3c962ad5b9a0a6456c" args="(const device_addr_t &amp;dev_addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9d9112f5eac0b53a721f2a6c97021fc1">sptr</a> <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#af0d3809a8f8dcd3c962ad5b9a0a6456c">uhd::usrp::multi_usrp::make</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1device__addr__t.html">device_addr_t</a> &amp;&#160;</td>
          <td class="paramname"><em>dev_addr</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make a new multi usrp from the device address. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_addr</td><td>the device address </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new single usrp object </dd></dl>

</div>
</div>
<a class="anchor" id="a1337a38862d6eb27db0aabe30977d8d1"></a><!-- doxytag: member="uhd::usrp::multi_usrp::read_rssi" ref="a1337a38862d6eb27db0aabe30977d8d1" args="(size_t chan=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#a009518b78c453470e2856bebf2746f37">UHD_DEPRECATED</a> double <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1337a38862d6eb27db0aabe30977d8d1">uhd::usrp::multi_usrp::read_rssi</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read the RSSI value on the RX frontend. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the rssi in dB </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if RSSI readback not supported </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aceddf575752fda1a8cc75513a1178fd9"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_clock_config" ref="aceddf575752fda1a8cc75513a1178fd9" args="(const clock_config_t &amp;clock_config, size_t mboard=ALL_MBOARDS)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#aceddf575752fda1a8cc75513a1178fd9">uhd::usrp::multi_usrp::set_clock_config</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structuhd_1_1clock__config__t.html">clock_config_t</a> &amp;&#160;</td>
          <td class="paramname"><em>clock_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the clock configuration for the usrp device. DEPRECATED in favor of set time and clock source calls. This tells the usrp how to get a 10Mhz reference and PPS clock. See the documentation for <a class="el" href="structuhd_1_1clock__config__t.html">clock_config_t</a> for more info. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">clock_config</td><td>the clock configuration to set </td></tr>
    <tr><td class="paramname">mboard</td><td>which motherboard to set the config </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a73ed40009d0d3787c183d42423d25026"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_clock_source" ref="a73ed40009d0d3787c183d42423d25026" args="(const std::string &amp;source, const size_t mboard=ALL_MBOARDS)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a73ed40009d0d3787c183d42423d25026">uhd::usrp::multi_usrp::set_clock_source</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the clock source for the usrp device. This sets the source for a 10 Mhz reference clock. Typical options for source: internal, external, MIMO. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>a string representing the clock source </td></tr>
    <tr><td class="paramname">mboard</td><td>which motherboard to set the config </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a191b78b00d051d3d51c2f719361c1fb5"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_command_time" ref="a191b78b00d051d3d51c2f719361c1fb5" args="(const uhd::time_spec_t &amp;time_spec, size_t mboard=ALL_MBOARDS)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a191b78b00d051d3d51c2f719361c1fb5">uhd::usrp::multi_usrp::set_command_time</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1time__spec__t.html">uhd::time_spec_t</a> &amp;&#160;</td>
          <td class="paramname"><em>time_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the time at which the control commands will take effect.</p>
<p>A timed command will back-pressure all subsequent timed commands, assuming that the subsequent commands occur within the time-window. If the time spec is late, the command will be activated upon arrival.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">time_spec</td><td>the time at which the next command will activate </td></tr>
    <tr><td class="paramname">mboard</td><td>which motherboard to set the config </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99254abfa5259b70a020e667eee619b9"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_master_clock_rate" ref="a99254abfa5259b70a020e667eee619b9" args="(double rate, size_t mboard=ALL_MBOARDS)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a99254abfa5259b70a020e667eee619b9">uhd::usrp::multi_usrp::set_master_clock_rate</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the master clock rate. This controls the rate of the clock that feeds the FPGA DSP. On some devices, this re-tunes the clock to the specified rate. If the specified rate is not available, this method will throw. On other devices, this method notifies the software of the rate, but requires the the user has made the necessary hardware change. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rate</td><td>the new master clock rate in Hz </td></tr>
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a72b7947cb0c434b98e9915f91b8f8fe0"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_rx_antenna" ref="a72b7947cb0c434b98e9915f91b8f8fe0" args="(const std::string &amp;ant, size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a72b7947cb0c434b98e9915f91b8f8fe0">uhd::usrp::multi_usrp::set_rx_antenna</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Select the RX antenna on the frontend. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ant</td><td>the antenna name </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4e026819f286e69c48c2e1956d95c6fb"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_rx_bandwidth" ref="a4e026819f286e69c48c2e1956d95c6fb" args="(double bandwidth, size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a4e026819f286e69c48c2e1956d95c6fb">uhd::usrp::multi_usrp::set_rx_bandwidth</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bandwidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the RX bandwidth on the frontend. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bandwidth</td><td>the bandwidth in Hz </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7beb49c1a04a81b3e7569db482453746"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_rx_dc_offset" ref="a7beb49c1a04a81b3e7569db482453746" args="(const bool enb, size_t chan=ALL_CHANS)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7beb49c1a04a81b3e7569db482453746">uhd::usrp::multi_usrp::set_rx_dc_offset</a> </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enable/disable the automatic RX DC offset correction. The automatic correction subtracts out the long-run average.</p>
<p>When disabled, the averaging option operation is halted. Once halted, the average value will be held constant until the user re-enables the automatic correction or overrides the value by manually setting the offset.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">enb</td><td>true to enable automatic DC offset correction </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b8212c1131a34823430c9bdec9c183f"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_rx_dc_offset" ref="a8b8212c1131a34823430c9bdec9c183f" args="(const std::complex&lt; double &gt; &amp;offset, size_t chan=ALL_CHANS)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7beb49c1a04a81b3e7569db482453746">uhd::usrp::multi_usrp::set_rx_dc_offset</a> </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set a constant RX DC offset value. The value is complex to control both I and Q. Only set this when automatic correction is disabled. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the dc offset (1.0 is full-scale) </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9b61448f392466e20572fdcb042e8ec6"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_rx_freq" ref="a9b61448f392466e20572fdcb042e8ec6" args="(const tune_request_t &amp;tune_request, size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1tune__result__t.html">tune_result_t</a> <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9b61448f392466e20572fdcb042e8ec6">uhd::usrp::multi_usrp::set_rx_freq</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structuhd_1_1tune__request__t.html">tune_request_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tune_request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the RX center frequency. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tune_request</td><td>tune request instructions </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a tune result object </dd></dl>

</div>
</div>
<a class="anchor" id="ad602e7681b796deddd9231f022ffef11"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_rx_gain" ref="ad602e7681b796deddd9231f022ffef11" args="(double gain, const std::string &amp;name, size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ad602e7681b796deddd9231f022ffef11">uhd::usrp::multi_usrp::set_rx_gain</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the RX gain value for the specified gain element. For an empty name, distribute across all gain elements. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gain</td><td>the gain in dB </td></tr>
    <tr><td class="paramname">name</td><td>the name of the gain element </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8234968ad1fefef299ef9541cc193915"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_rx_gain" ref="a8234968ad1fefef299ef9541cc193915" args="(double gain, size_t chan=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ad602e7681b796deddd9231f022ffef11">uhd::usrp::multi_usrp::set_rx_gain</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A convenience wrapper for setting overall RX gain. </p>

</div>
</div>
<a class="anchor" id="a7ccd212322a5da010ba79f9f18561156"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_rx_iq_balance" ref="a7ccd212322a5da010ba79f9f18561156" args="(const std::complex&lt; double &gt; &amp;correction, size_t chan=ALL_CHANS)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7ccd212322a5da010ba79f9f18561156">uhd::usrp::multi_usrp::set_rx_iq_balance</a> </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>correction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the RX frontend IQ imbalance correction. Use this to adjust the magnitude and phase of I and Q.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">correction</td><td>the complex correction (1.0 is full-scale) </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a587cfb5be38a16fec532793b34fbf947"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_rx_rate" ref="a587cfb5be38a16fec532793b34fbf947" args="(double rate, size_t chan=ALL_CHANS)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a587cfb5be38a16fec532793b34fbf947">uhd::usrp::multi_usrp::set_rx_rate</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the RX sample rate. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rate</td><td>the rate in Sps </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f94ed00059cc7dd30567d031b3f9679"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_rx_subdev_spec" ref="a7f94ed00059cc7dd30567d031b3f9679" args="(const uhd::usrp::subdev_spec_t &amp;spec, size_t mboard=ALL_MBOARDS)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7f94ed00059cc7dd30567d031b3f9679">uhd::usrp::multi_usrp::set_rx_subdev_spec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a> &amp;&#160;</td>
          <td class="paramname"><em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the RX frontend specification: The subdev spec maps a physical part of a daughter-board to a channel number. Set the subdev spec before calling into any methods with a channel number. The subdev spec must be the same size across all motherboards. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">spec</td><td>the new frontend specification </td></tr>
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a75b1c5375549e6a446d686ee7d9b4e14"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_time_next_pps" ref="a75b1c5375549e6a446d686ee7d9b4e14" args="(const time_spec_t &amp;time_spec, size_t mboard=ALL_MBOARDS)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a75b1c5375549e6a446d686ee7d9b4e14">uhd::usrp::multi_usrp::set_time_next_pps</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> &amp;&#160;</td>
          <td class="paramname"><em>time_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the time registers on the usrp at the next pps tick. The values will not be latched in until the pulse occurs. It is recommended that the user sleep(1) after calling to ensure that the time registers will be in a known state prior to use.</p>
<p>Note: Because this call sets the time on the "next" pps, the seconds in the time spec should be current seconds + 1.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">time_spec</td><td>the time to latch into the usrp device </td></tr>
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a351a2c3081944a0d2caab95e2a2f0926"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_time_now" ref="a351a2c3081944a0d2caab95e2a2f0926" args="(const time_spec_t &amp;time_spec, size_t mboard=ALL_MBOARDS)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a351a2c3081944a0d2caab95e2a2f0926">uhd::usrp::multi_usrp::set_time_now</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> &amp;&#160;</td>
          <td class="paramname"><em>time_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the time registers on the usrp immediately.</p>
<p>If only one MIMO master is present in your configuration, set_time_now is safe to use because the slave's time automatically follows the master's time. Otherwise, this call cannot set the time synchronously across multiple devices. Please use the set_time_next_pps or set_time_unknown_pps calls with a PPS signal.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">time_spec</td><td>the time to latch into the usrp device </td></tr>
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57a5580ba06d7d6a037c9ef64f1ea361"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_time_source" ref="a57a5580ba06d7d6a037c9ef64f1ea361" args="(const std::string &amp;source, const size_t mboard=ALL_MBOARDS)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a57a5580ba06d7d6a037c9ef64f1ea361">uhd::usrp::multi_usrp::set_time_source</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the time source for the usrp device. This sets the method of time synchronization, typically a pulse per second or an encoded time. Typical options for source: external, MIMO. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>a string representing the time source </td></tr>
    <tr><td class="paramname">mboard</td><td>which motherboard to set the config </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a413014bf3aea4a8ea2d268b4a3b390e9"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_time_unknown_pps" ref="a413014bf3aea4a8ea2d268b4a3b390e9" args="(const time_spec_t &amp;time_spec)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a413014bf3aea4a8ea2d268b4a3b390e9">uhd::usrp::multi_usrp::set_time_unknown_pps</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> &amp;&#160;</td>
          <td class="paramname"><em>time_spec</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Synchronize the times across all motherboards in this configuration. Use this method to sync the times when the edge of the PPS is unknown.</p>
<p>Ex: Host machine is not attached to serial port of GPSDO and can therefore not query the GPSDO for the PPS edge.</p>
<p>This is a 2-step process, and will take at most 2 seconds to complete. Upon completion, the times will be synchronized to the time provided.</p>
<ul>
<li>Step1: wait for the last pps time to transition to catch the edge</li>
<li>Step2: set the time at the next pps (synchronous for all boards)</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">time_spec</td><td>the time to latch at the next pps after catching the edge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4e8cd16aa93bf3375cdcd3daca3b6b24"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_tx_antenna" ref="a4e8cd16aa93bf3375cdcd3daca3b6b24" args="(const std::string &amp;ant, size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a4e8cd16aa93bf3375cdcd3daca3b6b24">uhd::usrp::multi_usrp::set_tx_antenna</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Select the TX antenna on the frontend. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ant</td><td>the antenna name </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad04bfc300735435a7937d4eb37e5523d"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_tx_bandwidth" ref="ad04bfc300735435a7937d4eb37e5523d" args="(double bandwidth, size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ad04bfc300735435a7937d4eb37e5523d">uhd::usrp::multi_usrp::set_tx_bandwidth</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bandwidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the TX bandwidth on the frontend. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bandwidth</td><td>the bandwidth in Hz </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a263ab7f0364c03e8a6e330c546769e4f"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_tx_dc_offset" ref="a263ab7f0364c03e8a6e330c546769e4f" args="(const std::complex&lt; double &gt; &amp;offset, size_t chan=ALL_CHANS)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a263ab7f0364c03e8a6e330c546769e4f">uhd::usrp::multi_usrp::set_tx_dc_offset</a> </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set a constant TX DC offset value. The value is complex to control both I and Q. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the dc offset (1.0 is full-scale) </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7a674a9d012a78dd4f2ded478839124"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_tx_freq" ref="ae7a674a9d012a78dd4f2ded478839124" args="(const tune_request_t &amp;tune_request, size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1tune__result__t.html">tune_result_t</a> <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ae7a674a9d012a78dd4f2ded478839124">uhd::usrp::multi_usrp::set_tx_freq</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structuhd_1_1tune__request__t.html">tune_request_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tune_request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the TX center frequency. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tune_request</td><td>tune request instructions </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a tune result object </dd></dl>

</div>
</div>
<a class="anchor" id="a41cc3c774451d0a2c5f69cd8df0f9f06"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_tx_gain" ref="a41cc3c774451d0a2c5f69cd8df0f9f06" args="(double gain, const std::string &amp;name, size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a41cc3c774451d0a2c5f69cd8df0f9f06">uhd::usrp::multi_usrp::set_tx_gain</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the TX gain value for the specified gain element. For an empty name, distribute across all gain elements. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gain</td><td>the gain in dB </td></tr>
    <tr><td class="paramname">name</td><td>the name of the gain element </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1101dc00b016fe91a299cbcae8b12053"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_tx_gain" ref="a1101dc00b016fe91a299cbcae8b12053" args="(double gain, size_t chan=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a41cc3c774451d0a2c5f69cd8df0f9f06">uhd::usrp::multi_usrp::set_tx_gain</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A convenience wrapper for setting overall TX gain. </p>

</div>
</div>
<a class="anchor" id="ad938e609a11773e21611ee86a0e1b1c5"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_tx_iq_balance" ref="ad938e609a11773e21611ee86a0e1b1c5" args="(const std::complex&lt; double &gt; &amp;correction, size_t chan=ALL_CHANS)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ad938e609a11773e21611ee86a0e1b1c5">uhd::usrp::multi_usrp::set_tx_iq_balance</a> </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>correction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the TX frontend IQ imbalance correction. Use this to adjust the magnitude and phase of I and Q.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">correction</td><td>the complex correction (1.0 is full-scale) </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab8bc17744d3ee94b7c5cdcb75457bd6b"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_tx_rate" ref="ab8bc17744d3ee94b7c5cdcb75457bd6b" args="(double rate, size_t chan=ALL_CHANS)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ab8bc17744d3ee94b7c5cdcb75457bd6b">uhd::usrp::multi_usrp::set_tx_rate</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the TX sample rate. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rate</td><td>the rate in Sps </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b8d9d9fb9a1ec51e81a207cd299e517"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_tx_subdev_spec" ref="a3b8d9d9fb9a1ec51e81a207cd299e517" args="(const uhd::usrp::subdev_spec_t &amp;spec, size_t mboard=ALL_MBOARDS)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3b8d9d9fb9a1ec51e81a207cd299e517">uhd::usrp::multi_usrp::set_tx_subdev_spec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a> &amp;&#160;</td>
          <td class="paramname"><em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the TX frontend specification: The subdev spec maps a physical part of a daughter-board to a channel number. Set the subdev spec before calling into any methods with a channel number. The subdev spec must be the same size across all motherboards. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">spec</td><td>the new frontend specification </td></tr>
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7c74905c18e464b8b3f59fb2dd70dbf3"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_user_register" ref="a7c74905c18e464b8b3f59fb2dd70dbf3" args="(const boost::uint8_t addr, const boost::uint32_t data, size_t mboard=ALL_MBOARDS)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7c74905c18e464b8b3f59fb2dd70dbf3">uhd::usrp::multi_usrp::set_user_register</a> </td>
          <td>(</td>
          <td class="paramtype">const boost::uint8_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::uint32_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Perform write on the user configuration register bus. These only exist if the user has implemented custom setting registers in the device FPGA. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>8-bit register address </td></tr>
    <tr><td class="paramname">data</td><td>32-bit register value </td></tr>
    <tr><td class="paramname">mboard</td><td>which motherboard to set the user register </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="afeaca319029cb49f7041461345ab641c"></a><!-- doxytag: member="uhd::usrp::multi_usrp::ALL_CHANS" ref="afeaca319029cb49f7041461345ab641c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">uhd::usrp::multi_usrp::ALL_CHANS</a> = size_t(~0)<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A wildcard channel index. </p>

</div>
</div>
<a class="anchor" id="a524b7e2177492e59382f1124ee32c12b"></a><!-- doxytag: member="uhd::usrp::multi_usrp::ALL_GAINS" ref="a524b7e2177492e59382f1124ee32c12b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a524b7e2177492e59382f1124ee32c12b">uhd::usrp::multi_usrp::ALL_GAINS</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A wildcard gain element name. </p>

</div>
</div>
<a class="anchor" id="a21f2ba01462e1f211a8823fda24a82d5"></a><!-- doxytag: member="uhd::usrp::multi_usrp::ALL_MBOARDS" ref="a21f2ba01462e1f211a8823fda24a82d5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">uhd::usrp::multi_usrp::ALL_MBOARDS</a> = size_t(~0)<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A wildcard motherboard index. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/uhd/usrp/<a class="el" href="multi__usrp_8hpp_source.html">multi_usrp.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Mon May 18 2015 16:53:08 for UHD by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
